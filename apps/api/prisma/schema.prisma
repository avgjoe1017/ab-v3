generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  struggle  String?  // Optional: what user is working on (e.g., "I'm dealing with imposter syndrome")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  preferences Preferences?
  sessions     Session[]
  entitlementState EntitlementState?
  entitlementEvents EntitlementEvent[]
  values         UserValue[]
}

model Preferences {
  userId       String @id
  schemaVersion Int
  json         String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

model Session {
  id        String   @id @default(uuid())
  ownerUserId String?
  source    String   // "catalog" | "user" | "generated"
  title     String
  goalTag   String?
  durationSec Int?
  voiceId   String
  pace      String?
  affirmationSpacingMs Int?
  affirmationsHash String
  frequencyHz Float?  // Binaural beat frequency in Hz (e.g., 10.0 for Alpha)
  brainwaveState String? // "Delta" | "Theta" | "Alpha" | "SMR" | "Beta"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ownerUser User? @relation(fields: [ownerUserId], references: [id], onDelete: SetNull)

  affirmations SessionAffirmation[]
  audio        SessionAudio?

  @@index([ownerUserId])
  @@index([source])
  @@index([affirmationsHash])
}

model SessionAffirmation {
  id        String @id @default(uuid())
  sessionId String
  idx       Int
  text      String

  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, idx])
  @@index([sessionId])
}

model AudioAsset {
  id        String   @id @default(uuid())
  kind      String   // "affirmationMerged" | "affirmationChunk" | "silence" | "background" | "binaural"
  hash      String
  url       String
  metaJson  String?
  createdAt DateTime @default(now())

  @@index([kind])
  sessionAudios SessionAudio[]
  @@unique([kind, hash])
}

model SessionAudio {
  sessionId String @id
  mergedAudioAssetId String
  generatedAt DateTime @default(now())

  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  mergedAudioAsset AudioAsset @relation(fields: [mergedAudioAssetId], references: [id])

  @@index([mergedAudioAssetId])
}

model EntitlementState {
  userId   String @id
  plan     String
  status   String
  renewsAt DateTime?
  source   String?
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model EntitlementEvent {
  id        String   @id @default(uuid())
  userId    String
  provider  String
  type      String
  payloadJson String
  occurredAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, occurredAt])
}

model Job {
  id        String   @id @default(uuid())
  type      String   // "ensure-audio"
  status    String   // "pending", "processing", "completed", "failed"
  payload   String   // JSON
  result    String?  // JSON
  error     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserValue {
  id        String   @id @default(uuid())
  userId    String
  valueId   String   // Value identifier (e.g., "achievement", "connection")
  valueText String   // Display text (e.g., "Achievement & Success")
  rank      Int?     // Ranking (1 = highest priority, null = unranked)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, rank])
}
